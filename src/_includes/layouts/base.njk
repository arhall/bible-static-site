<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="/assets/favicon.svg" type="image/svg+xml">
  <title>{{ title or 'Bible Explorer' }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/styles.css">
  <meta name="description" content="{{ description or 'Chapter-by-chapter Bible summaries with categories and metadata.' }}">
  <!-- OpenTelemetry Web SDK -->
  <script src="https://unpkg.com/@opentelemetry/api@1.7.0/build/esm/index.js" type="module"></script>
  <script src="https://unpkg.com/@opentelemetry/sdk-web@1.19.0/build/esm/index.js" type="module"></script>
  <script src="https://unpkg.com/@opentelemetry/auto-instrumentations-web@0.35.0/build/esm/index.js" type="module"></script>
  <!-- Logging System -->
  <script src="/assets/logger.js"></script>
  <!-- Telemetry System -->
  <script src="/assets/telemetry.js" type="module"></script>
  <!-- Debug Dashboard -->
  <script src="/assets/debug-dashboard.js"></script>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <a class="nav-brand" href="/">Bible Explorer</a>
      <div class="nav-links">
        <a href="/categories/" class="nav-link {% if page.url == '/categories/' %}active{% endif %}">Sections</a>
        <a href="/characters/" class="nav-link {% if page.url.startsWith('/characters/') %}active{% endif %}">Characters</a>
        <a href="/links/" class="nav-link {% if page.url == '/links/' %}active{% endif %}">Links</a>
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
          <span class="theme-icon">üåô</span>
        </button>
      </div>
    </nav>
    
    <div class="search-container">
      <div class="search-box">
        <div class="search-icon">üîç</div>
        <input type="text" class="search-input" placeholder="Search books, chapters, or summaries..." id="searchInput">
        <div class="search-results" id="searchResults"></div>
      </div>
    </div>
    
    {{ content | safe }}
    
    <footer class="footer">
      Built with <a href="https://www.11ty.dev/">Eleventy</a> ‚Ä¢ 2024
    </footer>
  </div>

  <script>
    // Search functionality
    let searchData = [];
    let searchTimeout;

    // Initialize search data
    async function initializeSearch() {
      try {
        const books = {{ books | dump | safe }};
        const categories = {{ categories | dump | safe }};
        const characters = {{ characters | dump | safe }};
        
        if (!books || !Array.isArray(books)) {
          throw new Error('Books data is invalid or missing');
        }
        
        if (!categories || !Array.isArray(categories)) {
          throw new Error('Categories data is invalid or missing');
        }
        
        if (!characters || !Array.isArray(characters)) {
          throw new Error('Characters data is invalid or missing');
        }
        
        // Process books and chapters into searchable items
        books.forEach((book, index) => {
          try {
            if (!book.name || !book.slug) {
              throw new Error(`Book at index ${index} missing required fields`);
            }
            
            // Add book itself
            let bookSubtitle = `üìñ Book by ${book.author || 'Unknown'} ‚Ä¢ ${book.category || 'Unknown'}`;
            
            // Special handling for single-chapter books that might be confused with characters
            const singleChapterBooks = ['Obadiah', 'Philemon', 'Jude', '2 John', '3 John'];
            if (singleChapterBooks.includes(book.name)) {
              bookSubtitle = `üìñ Single-chapter book by ${book.author || 'Unknown'} ‚Ä¢ ${book.category || 'Unknown'}`;
            }
            
            searchData.push({
              type: 'book',
              title: book.name,
              subtitle: bookSubtitle,
              content: `${book.name} ${book.author || ''} ${book.category || ''}`,
              url: `/books/${book.slug}/`,
              typeLabel: 'Book'
            });

            // Add chapters with summaries
            if (book.chapterSummaries && typeof book.chapterSummaries === 'object') {
              Object.entries(book.chapterSummaries).forEach(([chapter, summary]) => {
                if (summary && typeof summary === 'string') {
                  searchData.push({
                    type: 'chapter',
                    title: `${book.name} ${chapter}`,
                    subtitle: `üìÑ ${summary.substring(0, 80)}...`,
                    content: `${book.name} chapter ${chapter} ${summary}`,
                    url: `/books/${book.slug}/#chapter-${chapter}`,
                    typeLabel: 'Chapter'
                  });
                }
              });
            }
          } catch (bookError) {
            if (window.logger) {
              window.logger.error('Error processing book for search', { 
                book: book.name || 'unknown', 
                error: bookError.message 
              });
            }
          }
        });

        // Add categories
        categories.forEach((category, index) => {
          try {
            if (!category.name || !category.slug) {
              throw new Error(`Category at index ${index} missing required fields`);
            }
            
            searchData.push({
              type: 'category',
              title: category.name,
              subtitle: `üè∑Ô∏è ${category.description || 'Biblical section'}`,
              content: `${category.name} ${category.description || ''} ${category.themes ? category.themes.join(' ') : ''}`,
              url: `/categories/${category.slug}/`,
              typeLabel: 'Section'
            });
          } catch (categoryError) {
            if (window.logger) {
              window.logger.error('Error processing category for search', { 
                category: category.name || 'unknown', 
                error: categoryError.message 
              });
            }
          }
        });

        // Add characters
        characters.forEach((character, index) => {
          try {
            if (!character.name || !character.slug) {
              throw new Error(`Character at index ${index} missing required fields`);
            }
            
            searchData.push({
              type: 'character',
              title: character.name,
              subtitle: `üë§ ${character.totalAppearances} appearances in ${character.totalBooks} books`,
              content: `${character.name} ${character.books ? character.books.join(' ') : ''}`,
              url: `/characters/${character.slug}/`,
              typeLabel: 'Character'
            });
          } catch (characterError) {
            if (window.logger) {
              window.logger.error('Error processing character for search', { 
                character: character.name || 'unknown', 
                error: characterError.message 
              });
            }
          }
        });
        
        if (window.logger) {
          window.logger.info('Search initialization completed', {
            totalItems: searchData.length,
            books: books.length,
            categories: categories.length,
            characters: characters.length
          });
        }
        
      } catch (error) {
        const errorMessage = 'Search initialization failed: ' + error.message;
        console.error(errorMessage, error);
        
        // Log the error
        if (window.logger) {
          window.logger.error(errorMessage, { 
            error: error.message,
            stack: error.stack,
            component: 'search-init'
          });
        }
        
        if (window.telemetry) {
          window.telemetry.recordError(error, { component: 'search-initialization' });
        }
        
        // Fallback: show error message to user
        const searchContainer = document.querySelector('.search-container');
        if (searchContainer) {
          const errorDiv = document.createElement('div');
          errorDiv.style.cssText = 'background: #ff4444; color: white; padding: 0.5rem; border-radius: 4px; margin-bottom: 1rem; text-align: center;';
          errorDiv.textContent = 'Search functionality temporarily unavailable';
          searchContainer.appendChild(errorDiv);
        }
      }
    }

    // Search function
    function performSearch(query) {
      if (!query || query.length < 2) return [];
      
      try {
        const startTime = performance.now();
        const lowercaseQuery = query.toLowerCase();
        
        if (!searchData || !Array.isArray(searchData)) {
          throw new Error('Search data not properly initialized');
        }
        
        const results = searchData
          .map(item => {
            try {
              const score = calculateRelevance(item, lowercaseQuery);
              return { ...item, score };
            } catch (itemError) {
              if (window.logger) {
                window.logger.warn('Error calculating relevance for search item', { 
                  item: item.title || 'unknown', 
                  error: itemError.message 
                });
              }
              return { ...item, score: 0 };
            }
          })
          .filter(item => item.score > 0)
          .sort((a, b) => {
            // First sort by score
            if (b.score !== a.score) return b.score - a.score;
            
            // Then prioritize: books > characters > chapters > categories
            const typeOrder = { book: 1, character: 2, chapter: 3, category: 4 };
            return (typeOrder[a.type] || 5) - (typeOrder[b.type] || 5);
          })
          .slice(0, 10);
        
        const duration = performance.now() - startTime;
        
        // Log search with both logger and telemetry
        if (window.logger) {
          window.logger.search(query, results, duration);
        }
        if (window.telemetry) {
          window.telemetry.recordSearch(query, results.length, duration);
        }
        
        return results;
        
      } catch (error) {
        const errorMessage = 'Search operation failed: ' + error.message;
        console.error(errorMessage, error);
        
        // Log the error
        if (window.logger) {
          window.logger.error(errorMessage, { 
            query: query.substring(0, 50),
            error: error.message,
            component: 'search-perform'
          });
        }
        
        if (window.telemetry) {
          window.telemetry.recordError(error, { 
            component: 'search-operation',
            query_length: query.length 
          });
        }
        
        // Return empty results on error
        return [];
      }
    }

    // Calculate relevance score
    function calculateRelevance(item, query) {
      const content = item.content.toLowerCase();
      const title = item.title.toLowerCase();
      
      let score = 0;
      
      // Perfect title match gets highest score
      if (title === query) {
        score += 200;
        // Boost books and characters for exact matches
        if (item.type === 'book') score += 50;
        if (item.type === 'character') score += 40;
      }
      
      // Title starts with query
      if (title.startsWith(query)) {
        score += 150;
      }
      
      // Title contains query
      if (title.includes(query)) {
        score += 100;
      }
      
      // Content match gets medium score
      if (content.includes(query)) {
        score += 50;
      }
      
      // Word boundary matches get bonus
      const words = query.split(' ');
      words.forEach(word => {
        if (word.length > 2) {
          const regex = new RegExp('\\b' + word, 'i');
          if (regex.test(title)) score += 30;
          if (regex.test(content)) score += 15;
        }
      });
      
      // Type-based bonuses for better user experience
      if (item.type === 'book') score += 10;  // Slightly prioritize books
      if (item.type === 'character') score += 5;  // Then characters
      
      return score;
    }

    // Highlight search terms
    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      return text.replace(regex, '<span class="search-highlight">$1</span>');
    }

    // Display search results
    function displayResults(results, query) {
      const resultsContainer = document.getElementById('searchResults');
      
      if (results.length === 0) {
        resultsContainer.innerHTML = '<div class="search-result-item">No results found</div>';
      } else {
        resultsContainer.innerHTML = results.map(result => `
          <div class="search-result-item" onclick="handleSearchResultClick('${result.url}', '${result.type}', '${result.title.replace(/'/g, "\\'")}')">
            <div class="search-result-header">
              <div class="search-result-title">${highlightText(result.title, query)}</div>
              <div class="search-result-type">${result.typeLabel || result.type}</div>
            </div>
            <div class="search-result-snippet">${highlightText(result.subtitle, query)}</div>
          </div>
        `).join('');
      }
      
      resultsContainer.style.display = results.length > 0 || query.length > 1 ? 'block' : 'none';
    }

    // Handle search result clicks
    function handleSearchResultClick(url, type, title) {
      try {
        if (!url || typeof url !== 'string') {
          throw new Error('Invalid URL provided for navigation');
        }
        
        const searchInput = document.getElementById('searchInput');
        const searchQuery = searchInput ? searchInput.value : 'unknown';
        
        // Log user action
        if (window.logger) {
          window.logger.userAction('search-result-click', { 
            url, 
            type, 
            title,
            searchQuery 
          });
        }
        
        // Record navigation
        if (window.telemetry) {
          window.telemetry.recordNavigation('search-click', url, { 
            result_type: type,
            result_title: title 
          });
        }
        
        // Clear search results
        const searchResults = document.getElementById('searchResults');
        if (searchResults) {
          searchResults.style.display = 'none';
        }
        
        // For character results, add extra context
        if (type === 'character') {
          // Add slight delay to allow navigation start, then clear search
          setTimeout(() => {
            if (searchInput) {
              searchInput.blur();
            }
          }, 100);
        }
        
        // Navigate to the page
        window.location.href = url;
        
      } catch (error) {
        const errorMessage = 'Navigation failed: ' + error.message;
        console.error(errorMessage, error);
        
        // Log the error
        if (window.logger) {
          window.logger.error(errorMessage, { 
            url,
            type,
            title,
            error: error.message,
            component: 'search-navigation'
          });
        }
        
        if (window.telemetry) {
          window.telemetry.recordError(error, { 
            component: 'search-result-click',
            url: url 
          });
        }
        
        // Show user-friendly error
        alert('Sorry, there was an error navigating to that page. Please try again.');
      }
    }

    // Search input handler
    document.addEventListener('DOMContentLoaded', function() {
      initializeSearch();
      
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      
      searchInput.addEventListener('input', function() {
        const query = this.value.trim();
        
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          const results = performSearch(query);
          displayResults(results, query);
        }, 300);
      });
      
      // Hide results when clicking outside
      document.addEventListener('click', function(e) {
        if (!e.target.closest('.search-box')) {
          searchResults.style.display = 'none';
        }
      });
      
      // Show results when focusing search input
      searchInput.addEventListener('focus', function() {
        if (this.value.trim()) {
          const results = performSearch(this.value.trim());
          displayResults(results, this.value.trim());
        }
      });
      
      // Keyboard navigation
      searchInput.addEventListener('keydown', function(e) {
        const items = searchResults.querySelectorAll('.search-result-item');
        const selected = searchResults.querySelector('.search-result-item.selected');
        
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (selected) {
            selected.classList.remove('selected');
            const next = selected.nextElementSibling || items[0];
            next.classList.add('selected');
          } else if (items.length > 0) {
            items[0].classList.add('selected');
          }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (selected) {
            selected.classList.remove('selected');
            const prev = selected.previousElementSibling || items[items.length - 1];
            prev.classList.add('selected');
          } else if (items.length > 0) {
            items[items.length - 1].classList.add('selected');
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selected) {
            selected.click();
          }
        }
      });
    });

    // Theme toggle functionality
    function toggleTheme() {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      
      // Update theme toggle icon
      const themeIcon = document.querySelector('.theme-icon');
      if (themeIcon) {
        themeIcon.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
      }
      
      // Log theme change
      if (window.logger) {
        window.logger.userAction('theme-toggle', { theme: newTheme });
      }
    }

    // Initialize theme on page load
    document.addEventListener('DOMContentLoaded', function() {
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
      
      document.documentElement.setAttribute('data-theme', initialTheme);
      
      // Update theme toggle icon
      const themeIcon = document.querySelector('.theme-icon');
      if (themeIcon) {
        themeIcon.textContent = initialTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
      }
    });
  </script>
</body>
</html>
